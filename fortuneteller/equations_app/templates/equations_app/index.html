{% extends 'equations_app/base.html' %}
{% load static %}

{% block title %}Maxwell's Equations Tutorial{% endblock %}

{% block content %}

<!-- ========================== -->
<!-- == SECTION: Introduction == -->
<!-- ========================== -->
<section id="intro" class="content-card animated" data-section-id="intro" data-animation-container-id="p5-canvas-intro">
    <h2>Welcome to the World of Electromagnetism!</h2>
    <p>Light, radio waves, electricity, magnetism – these diverse phenomena are elegantly unified by a single set of principles: <strong>Maxwell's Equations</strong>. This interactive tutorial guides you through the core concepts underlying classical electromagnetism.</p>
    <p>Here's what we'll explore together:</p>
    <ul>
        <li>The four fundamental equations presented in both their <strong>integral</strong> (global) and <strong>differential</strong> (local) forms.</li>
        <li>How the theorems of vector calculus elegantly connect these two crucial perspectives.</li>
        <li>How <strong>complex numbers</strong> (phasors) provide a powerful mathematical shortcut for analyzing fields that oscillate in time.</li>
        <li>The impact of real-world materials, introducing concepts like electric susceptibility (\(\chi_e\)) and conductivity (\(\sigma\)).</li>
        <li>How these material properties naturally lead to the definition of <strong>complex permittivity</strong> (\(\varepsilon_c\)), a key tool for understanding waves in realistic media.</li>
    </ul>
    <p>This tutorial aims for clarity and intuition, building upon the rigorous foundations common in electromagnetics texts.</p>
</section>

<!-- ============================ -->
<!-- == SECTION: Foundation     == -->
<!-- ============================ -->
<section id="maxwell-foundation" class="content-card animated" data-section-id="maxwell-foundation" data-animation-container-id="p5-canvas-foundation">
    <h2>Maxwell's Equations: The Foundation</h2>
    <p>At their heart, these four equations describe the intricate dance between electric fields (\(\mathbf{E}\)), magnetic fields (\(\mathbf{B}\)), electric charges (\(\rho\)), and electric currents (\(\mathbf{J}\)). To handle the response of materials, we often use the auxiliary fields \(\mathbf{D}\) (electric displacement) and \(\mathbf{H}\) (magnetic intensity).</p>

    <article class="sub-section">
        <h3>Integral Form: The Global Perspective</h3>
        <p>Relates fields integrated over larger regions (surfaces or loops) to the total sources or rates of change within those regions.</p>
        <div class="equation-box">
            <p><strong>1. Gauss's Law (Electric):</strong> Total \(\mathbf{D}\) flux equals enclosed free charge \(Q_{enc}\).</p>
            <div class="equation">$$ \oint_S \mathbf{D} \cdot d\mathbf{A} = \int_V \rho \, dV $$</div>
            <p><strong>2. Gauss's Law (Magnetic):</strong> Total \(\mathbf{B}\) flux through any closed surface is zero (no magnetic monopoles).</p>
            <div class="equation">$$ \oint_S \mathbf{B} \cdot d\mathbf{A} = 0 $$</div>
            <p><strong>3. Faraday's Law of Induction:</strong> Changing \(\mathbf{B}\) flux induces circulating \(\mathbf{E}\) (EMF).</p>
            <div class="equation">$$ \oint_C \mathbf{E} \cdot d\mathbf{l} = -\frac{d}{dt} \int_S \mathbf{B} \cdot d\mathbf{A} $$</div>
            <p><strong>4. Ampère-Maxwell Law:</strong> Conduction current \( \mathbf{J} \) and displacement current \( \partial\mathbf{D}/\partial t \) create circulating \(\mathbf{H}\).</p>
            <div class="equation">$$ \oint_C \mathbf{H} \cdot d\mathbf{l} = \int_S \left( \mathbf{J} + \frac{\partial \mathbf{D}}{\partial t} \right) \cdot d\mathbf{A} $$</div>
        </div>
        <h4 class="python-example-title">Python Example #1: Surface & Volume Integrals (Conceptual)</h4>
        <p class="text-muted">Actual calculation requires numerical libraries (e.g., SciPy, FEniCS) and defined geometries/fields. Python can orchestrate this process.</p>
        <div class="code-container">
             <button class="copy-btn" title="Copy code"><svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
            <pre><code class="language-python">
# === Example 1: Verify Gauss's Law via Numerical Integration ===
import numpy as np
from scipy import integrate
from scipy.constants import epsilon_0, pi

# --- Define D Field (Point Charge at Origin) ---
# D = Q / (4 * pi * r^2) * r_hat
# In spherical coords (r, theta, phi): D = [D_r, D_theta, D_phi]
Q_SOURCE = 1e-9 # 1 nanoCoulomb source charge

def d_field_spherical(r, theta, phi):
    """ Returns D field components [Dr, Dt, Dp] in SPHERICAL coords. """
    if r < 1e-9: return np.array([0.0, 0.0, 0.0]) # Avoid singularity
    D_r = Q_SOURCE / (4 * pi * r**2)
    return np.array([D_r, 0.0, 0.0])

# --- Define Charge Density (Uniform sphere) ---
R_CHARGE_DIST = 0.5 # Radius of the sphere containing charge (meters)
# Calculate rho_0 so the total charge inside R_CHARGE_DIST equals Q_SOURCE
charge_volume = (4/3) * pi * R_CHARGE_DIST**3
RHO_0 = Q_SOURCE / charge_volume # Uniform charge density (C/m^3)

def charge_density_rho(r, theta, phi):
    """ Returns charge density rho (uniform sphere). """
    return RHO_0 if r <= R_CHARGE_DIST else 0.0

# --- Choose Integration Surface (Gaussian Sphere) ---
R_GAUSSIAN = 1.0 # Radius of Gaussian surface (meters), must enclose charge

# --- 1. Calculate Flux Integral (Left Side of Gauss's Law) ---
# Integrate D dot dA over Gaussian sphere
# dA = r^2 * sin(theta) dtheta dphi * r_hat (normal vector)
# D dot dA = D_r * (r^2 * sin(theta) dtheta dphi)

def flux_integrand(theta, phi): # Integrate over theta, phi at fixed r
    r = R_GAUSSIAN
    D_r = d_field_spherical(r, theta, phi)[0]
    jacobian = (r**2) * np.sin(theta) # dA element excluding dr
    return D_r * jacobian

# Use dblquad for 2D integral (theta, phi)
total_flux, flux_error = integrate.dblquad(
    flux_integrand, # Function (theta, phi)
    0, 2 * pi,      # phi limits
    0, np.pi        # theta limits
)

print(f"--- Flux Calculation (∮ D⋅dA) ---")
print(f"Gaussian Surface Radius R = {R_GAUSSIAN} m")
print(f"Source Charge Q = {Q_SOURCE:.2e} C")
print(f"Calculated Total Flux ≈ {total_flux:.3e} C")
print(f"Theoretical Flux (should equal Q_SOURCE) = {Q_SOURCE:.3e} C")
print(f"Numerical Error ≈ {flux_error:.1e}")


# --- 2. Calculate Enclosed Charge (Right Side of Gauss's Law) ---
# Integrate rho dV over the volume enclosed by Gaussian sphere
# dV = r^2 * sin(theta) dr dtheta dphi

def charge_integrand(r, theta, phi): # Integrate over r, theta, phi
    rho = charge_density_rho(r, theta, phi)
    jacobian = (r**2) * np.sin(theta) # dV element excluding differentials
    return rho * jacobian

# Use tplquad for 3D integral (r, theta, phi)
# Note: Order of limits corresponds to order of args in func (r, theta, phi)
total_charge_enclosed, charge_error = integrate.tplquad(
    charge_integrand, # Function(r, theta, phi)
    0, 2 * pi,        # phi limits
    0, np.pi,         # theta limits
    0, R_GAUSSIAN     # r limits (integrate up to Gaussian surface)
)

print(f"\n--- Enclosed Charge Calculation (∫ ρ dV) ---")
print(f"Charge Density Radius = {R_CHARGE_DIST} m")
print(f"Integration Volume Radius (Gaussian) = {R_GAUSSIAN} m")
print(f"Calculated Enclosed Charge ≈ {total_charge_enclosed:.3e} C")

# Calculate theoretical enclosed charge based on radii
if R_GAUSSIAN >= R_CHARGE_DIST:
    expected_enclosed_charge = Q_SOURCE # Gaussian surface encloses all charge
else: # Gaussian surface is smaller than charge distribution
    expected_enclosed_charge = RHO_0 * (4/3 * pi * R_GAUSSIAN**3)

print(f"Theoretical Enclosed Charge = {expected_enclosed_charge:.3e} C")
print(f"Numerical Error ≈ {charge_error:.1e}")

print("\n--- Verification ---")
# The two calculated values should be very close (within numerical error)
if np.isclose(total_flux, total_charge_enclosed):
    print("✅ Gauss's Law Verified: Calculated Flux ≈ Calculated Enclosed Charge")
else:
    print("❌ Gauss's Law Verification Failed: Flux ≠ Enclosed Charge")
            </code></pre>
        </div>
    </article>

    <article class="sub-section">
        <h3>Differential Form: The Local Perspective</h3>
        <p>Describes precisely how the fields behave at every single point (\(x, y, z\)) in space at a specific time \(t\).</p>
        <div class="equation-box">
            <p><strong>1. Gauss (E):</strong> \( \nabla \cdot \mathbf{D} = \rho \)</p>
            <p><strong>2. Gauss (B):</strong> \( \nabla \cdot \mathbf{B} = 0 \)</p>
            <p><strong>3. Faraday:</strong> \( \nabla \times \mathbf{E} = -\frac{\partial \mathbf{B}}{\partial t} \)</p>
            <p><strong>4. Ampère-Maxwell:</strong> \( \nabla \times \mathbf{H} = \mathbf{J} + \frac{\partial \mathbf{D}}{\partial t} \)</p>
        </div>
         <h4 class="python-example-title">Python Example #2: Divergence & Curl (Symbolic/Numerical)</h4>
         <p class="text-muted">Requires libraries like SymPy for symbolic math or finite difference methods for numerical calculation.</p>
         <div class="code-container">
             <button class="copy-btn" title="Copy code"><svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
            <pre><code class="language-python">
# === Example 2: Calculating Divergence and Curl ===
import numpy as np

# --- Part 1: Symbolic Calculation using SymPy (Recommended for symbolic math) ---
try:
    import sympy
    from sympy.vector import CoordSys3D, divergence, curl

    print("--- Symbolic Calculation (using SymPy) ---")
    # Define symbolic coordinates
    x, y, z = sympy.symbols('x y z')
    # Define coordinate system
    N = CoordSys3D('N')
    # Define a symbolic vector field F = [Fx, Fy, Fz]
    # Example: F = (x*y*z, -y^2*z, x + z)
    Fx = x * y * z
    Fy = -y**2 * z
    Fz = x + z
    F_vector = Fx*N.i + Fy*N.j + Fz*N.k

    # Calculate exact Divergence: d(Fx)/dx + d(Fy)/dy + d(Fz)/dz
    div_F = divergence(F_vector)

    # Calculate exact Curl: [dFz/dy-dFy/dz, dFx/dz-dFz/dx, dFy/dx-dFx/dy]
    curl_F = curl(F_vector)

    print(f"Vector Field F = {F_vector}")
    print(f"Divergence (∇ · F) = {div_F}")
    print(f"Curl (∇ × F) = {curl_F}")

    # Evaluate at a point (e.g., P=(1, 2, 3))
    point_sym = {x: 1, y: 2, z: 3}
    div_at_P = div_F.subs(point_sym)
    curl_at_P = curl_F.subs(point_sym)
    print(f"\nAt Point P=(1, 2, 3):")
    print(f"  Divergence = {div_at_P}")
    print(f"  Curl = {curl_at_P}")

except ImportError:
    print("--- Symbolic Calculation (SymPy not installed) ---")
    print("Install SymPy ('pip install sympy') for symbolic results.")


# --- Part 2: Numerical Approximation (Plain Python + NumPy, Finite Differences) ---
print("\n--- Numerical Approximation (Finite Differences) ---")

# Define the same field as a Python function returning NumPy arrays
def F_numeric(x_val, y_val, z_val):
    fx = x_val * y_val * z_val
    fy = -y_val**2 * z_val
    fz = x_val + z_val
    return np.array([fx, fy, fz])

def numerical_divergence(F_func, x0, y0, z0, h=1e-4):
    """ Approximates divergence using central differences. """
    # Calculate field components at slightly offset points
    Fx_plus_h = F_func(x0 + h, y0, z0)[0]
    Fx_minus_h = F_func(x0 - h, y0, z0)[0]
    Fy_plus_h = F_func(x0, y0 + h, z0)[1]
    Fy_minus_h = F_func(x0, y0 - h, z0)[1]
    Fz_plus_h = F_func(x0, y0, z0 + h)[2]
    Fz_minus_h = F_func(x0, y0, z0 - h)[2]

    # Approximate partial derivatives
    dFx_dx = (Fx_plus_h - Fx_minus_h) / (2*h)
    dFy_dy = (Fy_plus_h - Fy_minus_h) / (2*h)
    dFz_dz = (Fz_plus_h - Fz_minus_h) / (2*h)

    return dFx_dx + dFy_dy + dFz_dz

def numerical_curl(F_func, x0, y0, z0, h=1e-4):
    """ Approximates curl using central differences. """
    # Get field components at offset points needed for curl
    F_x_y_plus_h = F_func(x0, y0 + h, z0)
    F_x_y_minus_h = F_func(x0, y0 - h, z0)
    F_x_z_plus_h = F_func(x0, y0, z0 + h)
    F_x_z_minus_h = F_func(x0, y0, z0 - h)

    F_y_x_plus_h = F_func(x0 + h, y0, z0)
    F_y_x_minus_h = F_func(x0 - h, y0, z0)
    F_y_z_plus_h = F_func(x0, y0, z0 + h)
    F_y_z_minus_h = F_func(x0, y0, z0 - h)

    F_z_x_plus_h = F_func(x0 + h, y0, z0)
    F_z_x_minus_h = F_func(x0 - h, y0, z0)
    F_z_y_plus_h = F_func(x0, y0 + h, z0)
    F_z_y_minus_h = F_func(x0, y0 - h, z0)

    # Approximate partial derivatives needed for curl components
    dFz_dy = (F_z_y_plus_h[2] - F_z_y_minus_h[2]) / (2*h)
    dFy_dz = (F_y_z_plus_h[1] - F_y_z_minus_h[1]) / (2*h)

    dFx_dz = (F_x_z_plus_h[0] - F_x_z_minus_h[0]) / (2*h)
    dFz_dx = (F_z_x_plus_h[2] - F_z_x_minus_h[2]) / (2*h)

    dFy_dx = (F_y_x_plus_h[1] - F_y_x_minus_h[1]) / (2*h)
    dFx_dy = (F_x_y_plus_h[0] - F_x_y_minus_h[0]) / (2*h)

    # Calculate curl components
    curl_x = dFz_dy - dFy_dz
    curl_y = dFx_dz - dFz_dx
    curl_z = dFy_dx - dFx_dy

    return np.array([curl_x, curl_y, curl_z])

# Evaluate numerical approximation at the same point P=(1, 2, 3)
x_P, y_P, z_P = 1, 2, 3
div_num_P = numerical_divergence(F_numeric, x_P, y_P, z_P)
curl_num_P = numerical_curl(F_numeric, x_P, y_P, z_P)

print(f"\nAt Point P=(1, 2, 3):")
print(f"  Numerical Divergence ≈ {div_num_P:.6f}")
print(f"  Numerical Curl ≈ [{curl_num_P[0]:.6f}, {curl_num_P[1]:.6f}, {curl_num_P[2]:.6f}]")

# Compare if SymPy was available
if 'sympy' in globals():
    print("\n--- Comparison ---")
    sym_div = float(div_at_P) # Convert sympy result to float
    sym_curl = np.array([float(c) for c in curl_at_P.components.values()])
    print(f"  SymPy Div  = {sym_div:.6f}")
    print(f"  SymPy Curl = [{sym_curl[0]:.6f}, {sym_curl[1]:.6f}, {sym_curl[2]:.6f}]")
    print(f"  Div Error: {abs(div_num_P - sym_div):.2e}")
    print(f"  Curl Error Mag: {np.linalg.norm(curl_num_P - sym_curl):.2e}")
            </code></pre>
        </div>
    </article>
</section> <!-- End of Maxwell Foundation Section -->


<!-- ============================ -->
<!-- == SECTION: Bridging Forms == -->
<!-- ============================ -->
<section id="bridging" class="content-card animated" data-section-id="bridging" data-animation-container-id="p5-canvas-bridging">
    <h2>Bridging the Forms: Vector Calculus Theorems</h2>
    <p>How do we mathematically link the global (integral) view to the local (differential) view? Two fundamental theorems of vector calculus are the keys:</p>
    <div class="theorem-box">
        <h4>The Divergence Theorem (Gauss's Theorem)</h4>
        <p>Connects the total flux (net outflow) of \(\mathbf{F}\) through a closed surface \(S\) to the sum of the divergence (\(\nabla \cdot \mathbf{F}\), the source density) throughout the enclosed volume \(V\).</p>
        <div class="equation">$$ \oint_S \mathbf{F} \cdot d\mathbf{A} = \int_V (\nabla \cdot \mathbf{F}) \, dV $$</div>
        <p class="intuition"><em>Analogy: Total water flow out of a container = sum of all faucet flows inside.</em></p>
    </div>
    <div class="theorem-box">
        <h4>Stokes' Theorem (Curl Theorem)</h4>
        <p>Connects the circulation (line integral) of \(\mathbf{F}\) around a closed loop \(C\) to the total flux of its curl (\(\nabla \times \mathbf{F}\), the "swirl density") through any open surface \(S\) bounded by \(C\).</p>
        <div class="equation">$$ \oint_C \mathbf{F} \cdot d\mathbf{l} = \int_S (\nabla \times \mathbf{F}) \cdot d\mathbf{A} $$</div>
        <p class="intuition"><em>Analogy: Rotation of a large paddle wheel at the edge = sum of rotations of tiny wheels inside.</em></p>
    </div>

    <h3 class="interactive-title">Interactive Derivations: See it in Action!</h3>
    <p>Let's apply these. Click 'Next Step' below each derivation.</p>

    <!-- Gauss Derivation -->
    <div class="interactive-derivation animated" data-derivation-id="gauss-deriv">
        <h4>Gauss's Law (E): Integral \(\rightarrow\) Differential</h4>
        <div class="derivation-steps">
            <div class="step active" data-step="1"><strong>Step 1: Integral Form & Charge Density</strong><br> Start with Gauss's Law integral form and express \(Q_{enc}\) as a volume integral of charge density \(\rho\).<br> \[ \oint_S \mathbf{D} \cdot d\mathbf{A} = \int_V \rho \, dV \]</div>
            <div class="step" data-step="2"><strong>Step 2: Apply Divergence Theorem</strong><br> Use the Divergence Theorem to convert the surface integral of \(\mathbf{D}\) on the left into a volume integral of its divergence, \(\nabla \cdot \mathbf{D}\).<br> \[ \int_V (\nabla \cdot \mathbf{D}) \, dV = \int_V \rho \, dV \]</div>
            <div class="step" data-step="3"><strong>Step 3: Pointwise Equality Argument</strong><br> Since this equation must hold true for *any* arbitrary volume \(V\) we choose, the functions inside the integrals (the integrands) must be equal at every point.<br> \[ \implies \quad \nabla \cdot \mathbf{D} = \rho \] <p class="feedback correct" style="margin-top: 1em; display:block;">Differential form derived!</p></div>
        </div>
        <button class="btn btn-secondary derivation-button">Next Step</button>
    </div>

     <!-- Faraday Derivation -->
     <div class="interactive-derivation animated" data-derivation-id="faraday-deriv">
        <h4>Faraday's Law: Integral \(\rightarrow\) Differential</h4>
         <div class="derivation-steps">
            <div class="step active" data-step="1"><strong>Step 1: Integral Form & Time Derivative</strong><br> Begin with Faraday's Law. Assume the loop \(C\) and surface \(S\) are fixed. The total derivative \(d/dt\) on the flux integral can move inside as a partial derivative \( \partial / \partial t \) on \(\mathbf{B}\).<br> \[ \oint_C \mathbf{E} \cdot d\mathbf{l} = -\frac{d}{dt} \int_S \mathbf{B} \cdot d\mathbf{A} \quad \implies \quad \oint_C \mathbf{E} \cdot d\mathbf{l} = -\int_S \frac{\partial \mathbf{B}}{\partial t} \cdot d\mathbf{A} \]</div>
            <div class="step" data-step="2"><strong>Step 2: Apply Stokes' Theorem</strong><br> Use Stokes' Theorem on the left-hand side to convert the line integral of \(\mathbf{E}\) into a surface integral of its curl (\(\nabla \times \mathbf{E}\)).<br> \[ \int_S (\nabla \times \mathbf{E}) \cdot d\mathbf{A} = -\int_S \frac{\partial \mathbf{B}}{\partial t} \cdot d\mathbf{A} \]</div>
            <div class="step" data-step="3"><strong>Step 3: Pointwise Equality Argument</strong><br> This equality must hold for *any* surface \(S\) bounded by the loop \(C\). Therefore, the integrands must be identical everywhere on the surface.<br> \[ \implies \quad \nabla \times \mathbf{E} = -\frac{\partial \mathbf{B}}{\partial t} \] <p class="feedback correct" style="margin-top: 1em; display:block;">Differential form derived!</p></div>
        </div>
         <button class="btn btn-secondary derivation-button">Next Step</button>
    </div>

    <!-- Ampere-Maxwell Derivation -->
    <div class="interactive-derivation animated" data-derivation-id="ampere-deriv">
        <h4>Ampère-Maxwell: Integral \(\rightarrow\) Differential</h4>
        <div class="derivation-steps">
             <div class="step active" data-step="1"><strong>Step 1: Integral Form & Combine Terms</strong><br> Start with Ampère-Maxwell. Combine the conduction current (\(J\)) and displacement current (\(\partial D / \partial t\)) terms under a single surface integral.<br> \[ \oint_C \mathbf{H} \cdot d\mathbf{l} = \int_S \mathbf{J} \cdot d\mathbf{A} + \int_S \frac{\partial \mathbf{D}}{\partial t} \cdot d\mathbf{A} = \int_S \left( \mathbf{J} + \frac{\partial \mathbf{D}}{\partial t} \right) \cdot d\mathbf{A} \] <p class="text-muted" style="font-size: 0.85em;">(Using \( \partial/\partial t \) assuming a fixed surface S).</p></div>
            <div class="step" data-step="2"><strong>Step 2: Apply Stokes' Theorem</strong><br> Use Stokes' Theorem on the left side, converting the line integral of \(\mathbf{H}\) into a surface integral of its curl (\(\nabla \times \mathbf{H}\)).<br> \[ \int_S (\nabla \times \mathbf{H}) \cdot d\mathbf{A} = \int_S \left( \mathbf{J} + \frac{\partial \mathbf{D}}{\partial t} \right) \cdot d\mathbf{A} \]</div>
            <div class="step" data-step="3"><strong>Step 3: Pointwise Equality Argument</strong><br> As this holds for any surface \(S\), the integrands must be equal.<br> \[ \implies \quad \nabla \times \mathbf{H} = \mathbf{J} + \frac{\partial \mathbf{D}}{\partial t} \] <p class="feedback correct" style="margin-top: 1em; display:block;">Differential form derived!</p></div>
        </div>
        <button class="btn btn-secondary derivation-button">Next Step</button>
    </div>
</section> <!-- End of Bridging Section -->


<!-- ================================ -->
<!-- == SECTION: Complex Convention == -->
<!-- ================================ -->
<section id="complex-convention" class="content-card animated" data-section-id="complex-convention" data-animation-container-id="p5-canvas-phasor">
    <h2>Complex Fields: Simplifying Oscillations</h2>
    <p>When dealing with waves or AC circuits, fields often oscillate sinusoidally. Working with sines and cosines in differential equations is cumbersome. Complex exponentials make life much easier!</p>
    <p class="highlight-box"><strong>The Convention (\( e^{-i\omega t} \)):</strong> We represent a real oscillating quantity, like \( A(t) = A_0 \cos(\omega t + \phi) \), as the real part of a complex exponential: \( A(t) = \text{Re}\{ \mathcal{A} e^{-i\omega t} \} \). Here, \( \mathcal{A} = A_0 e^{i\phi} \) is the complex <strong>phasor</strong> amplitude, encoding both magnitude (\(A_0\)) and initial phase (\(\phi\)). We use the \(e^{-i\omega t}\) convention common in physics.</p>
     <h4 class="python-example-title">Python Example #3: Representing Phasors</h4>
     <p class="text-muted">Using Python's built-in `complex` type and `numpy`.</p>
     <div class="code-container">
        <button class="copy-btn" title="Copy code"><svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
        <pre><code class="language-python">
# === Example 3: Phasor Representation & Operations ===
import numpy as np

# --- Define Signal Parameters ---
A0 = 5.0            # Real amplitude (e.g., V/m)
phi_deg = -60.0     # Initial phase shift in degrees
freq_hz = 2e9       # Frequency = 2 GHz

# --- Calculations ---
phi_rad = np.deg2rad(phi_deg)
omega = 2 * np.pi * freq_hz

# 1. Create the Phasor (Complex Amplitude)
# Phasor A = A0 * exp(i * phi)
phasor_A = A0 * np.exp(1j * phi_rad)

print("--- Phasor Definition ---")
print(f"Signal: A(t) = {A0:.1f} * cos({omega:.2e}*t + {phi_deg:.1f}°)")
print(f"Phasor A = {phasor_A}")
print(f"  Magnitude |A| = {np.abs(phasor_A):.3f} (Should match A0)")
print(f"  Phase arg(A) = {np.rad2deg(np.angle(phasor_A)):.1f}° (Should match phi_deg)")

# 2. Recover Real Signal at Specific Times
print("\n--- Signal Recovery (using Re{A * exp(-iwt)}) ---")
times_to_check_ns = np.array([0, 0.125, 0.25, 0.5]) # Example times in nanoseconds
times_s = times_to_check_ns * 1e-9 # Convert to seconds

for t_s, t_ns in zip(times_s, times_to_check_ns):
    # Calculate the full complex value at time t
    complex_value_at_t = phasor_A * np.exp(-1j * omega * t_s)
    # Recover the real instantaneous value
    real_value_at_t = complex_value_at_t.real # Same as np.real()

    # Verify with direct cosine calculation
    direct_value = A0 * np.cos(omega * t_s + phi_rad)

    print(f"Time t = {t_ns} ns:")
    print(f"  Full Complex Value = {complex_value_at_t:.2f}")
    print(f"  Recovered Real A(t) = {real_value_at_t:.3f}")
    print(f"  Direct cos() Check = {direct_value:.3f} {'✅' if np.isclose(real_value_at_t, direct_value) else '❌'}")

# 3. Derivative Equivalence: d/dt <=> -i*omega
print("\n--- Derivative Equivalence (d/dt <=> -i*omega) ---")
# Analytically, d/dt [A0*cos(wt + phi)] = -A0*omega*sin(wt + phi)
# Phasor of the derivative should be: -i*omega*Phasor_A
phasor_dA_dt = -1j * omega * phasor_A

# Calculate derivative directly at t=0 for comparison
t0 = 0.0
derivative_direct = -A0 * omega * np.sin(omega * t0 + phi_rad)

# Recover real value from derivative phasor at t=0
derivative_recovered = np.real(phasor_dA_dt * np.exp(-1j * omega * t0))

print(f"Phasor of original A:    {phasor_A:.2f}")
print(f"Phasor of dA/dt (-iωA): {phasor_dA_dt:.2e}")
print(f"\nAt t=0:")
print(f"  Recovered Real dA/dt(0) = {derivative_recovered:.3e}")
print(f"  Direct Derivative Check = {derivative_direct:.3e} {'✅' if np.isclose(derivative_recovered, derivative_direct) else '❌'}")

# The magnitude of the derivative phasor should be omega*A0
print(f"  Magnitude |dA/dt| = {np.abs(phasor_dA_dt):.3e}")
print(f"  Check |omega*A0|  = {omega * A0:.3e}")
# The phase of the derivative phasor should be phi + 90deg (or phi - 90deg depending on sign convention/sin)
# -i = e^(-i*pi/2). So mult by -i subtracts 90 deg from phase.
expected_phase_deg = phi_deg - 90
calculated_phase_deg = np.rad2deg(np.angle(phasor_dA_dt))
# Adjust calculated phase to be comparable (e.g., within -180 to 180)
calculated_phase_deg = (calculated_phase_deg + 180) % 360 - 180
expected_phase_deg = (expected_phase_deg + 180) % 360 - 180

print(f"  Phase arg(dA/dt) = {calculated_phase_deg:.1f}°")
print(f"  Expected Phase (φ - 90°) = {expected_phase_deg:.1f}°")
            </code></pre>
    </div>
    <article class="sub-section">
        <h3>The Magic: \( \partial / \partial t \rightarrow -i\omega \)</h3>
        <p>The key simplification: \( \frac{d}{dt} (e^{-i\omega t}) = -i\omega e^{-i\omega t} \). This means \( \partial/\partial t \) corresponds to multiplying the complex phasor by \( -i\omega \).</p>
        <div class="equation">$$ \boxed{ \frac{\partial}{\partial t} \iff -i\omega } $$</div>
    </article>
    <article class="sub-section">
        <h3>Maxwell's Equations for Phasors</h3>
        <p>Substituting \( -i\omega \) for \( \partial/\partial t \) gives time-independent phasor equations:</p>
        <div class="equation-box">
            <p>\( \nabla \cdot \mathbf{\mathcal{D}} = \rho_{\mathcal{P}} \)</p>
            <p>\( \nabla \cdot \mathbf{\mathcal{B}} = 0 \)</p>
            <p>\( \boxed{ \nabla \times \mathbf{\mathcal{E}} = i\omega \mathbf{\mathcal{B}} } \)</p>
            <p>\( \boxed{ \nabla \times \mathbf{\mathcal{H}} = \mathbf{\mathcal{J}} - i\omega \mathbf{\mathcal{D}} } \)</p>
        </div>
        <p>These involve only spatial derivatives, simplifying wave analysis.</p>
    </article>
</section> <!-- End Complex Convention -->

<!-- ========================================================== -->
<!-- == SECTION: Materials & Electric Susceptibility (\(\chi\)) == -->
<!-- ========================================================== -->
<section id="constitutive" class="content-card animated" data-section-id="constitutive" data-animation-container-id="p5-canvas-materials">
    <h2>Materials & Electric Susceptibility (\(\chi_e\))</h2>
    <p>Fields interact with matter! The <strong>constitutive relations</strong> link auxiliary fields (\(\mathbf{D}, \mathbf{H}\)) and current (\(\mathbf{J}\)) to fundamental fields (\(\mathbf{E}, \mathbf{B}\)), describing the material's response.</p>
    <article class="sub-section">
        <h3>Electric Response: Polarization & Susceptibility</h3>
        <p>In a dielectric, \(\mathbf{E}\) displaces bound charges, creating dipoles. Average dipole moment/volume = <strong>Polarization</strong> \(\mathbf{P}\).</p>
        <p>For linear materials: \( \mathbf{P} = \varepsilon_0 \chi_e \mathbf{E} \), where \( \chi_e \) is <strong>electric susceptibility</strong>.</p>
        <p>Displacement \(\mathbf{D}\) includes polarization: \( \mathbf{D} = \varepsilon_0 \mathbf{E} + \mathbf{P} = \varepsilon_0 (1 + \chi_e) \mathbf{E} \)</p>
    </article>
    <article class="sub-section">
        <h3>Permittivity, Conductivity & Ohm's Law</h3>
        <p>Comparing \(\mathbf{D} = \varepsilon_0 (1 + \chi_e) \mathbf{E}\) with \(\mathbf{D} = \varepsilon \mathbf{E}\), defines <strong>Permittivity</strong> \( \varepsilon \) as:</p>
        <div class="equation">$$ \varepsilon = \varepsilon_0 (1 + \chi_e) $$</div>
        <p>And <strong>relative permittivity</strong> \( \varepsilon_r \) (dielectric constant) as:</p>
        <div class="equation">$$ \boxed{ \varepsilon_r = \varepsilon / \varepsilon_0 = 1 + \chi_e } $$</div>
        <p>Ohm's Law relates conduction current density \(\mathbf{J}\) to \(\mathbf{E}\) via <strong>Conductivity</strong> \(\sigma\):</p>
        <div class="equation">$$ \mathbf{J} = \sigma \mathbf{E} $$</div>
         <h4 class="python-example-title">Python Example #4: Material Response Calculation</h4>
         <p class="text-muted">Calculate D, J, eps_r from basic properties.</p>
         <div class="code-container">
             <button class="copy-btn" title="Copy code"><svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
            <pre><code class="language-python">
# === Example 4: Applying Constitutive Relations ===
import numpy as np
from scipy.constants import epsilon_0

# --- Define Material Properties ---
# Example: Water at low frequency (simplified)
chi_e = 79.0      # Electric susceptibility (approx. for water, eps_r = 80)
sigma = 5e-6      # Conductivity (S/m, typical for purified water, can vary widely)
# Assume non-magnetic: mu_r = 1.0, mu = mu_0

# --- Applied Electric Field (Assume uniform vector) ---
E_field_vector = np.array([0.0, 1.0, 0.0]) # 1 V/m in y-direction

# --- Calculations ---

# 1. Permittivity from Susceptibility
epsilon_r = 1 + chi_e
epsilon_abs = epsilon_0 * epsilon_r # Absolute permittivity

# 2. Polarization Density (P = eps0 * chi_e * E)
P_vector = epsilon_0 * chi_e * E_field_vector

# 3. Electric Displacement Field (D = eps * E)
D_vector_from_eps = epsilon_abs * E_field_vector

# 4. Electric Displacement Field (D = eps0*E + P) - Verification
D_vector_from_P = epsilon_0 * E_field_vector + P_vector

# 5. Conduction Current Density (J = sigma * E)
J_vector = sigma * E_field_vector

# --- Print Results ---
print("--- Material Properties ---")
print(f"Electric Susceptibility (χe): {chi_e:.2f}")
print(f"Conductivity          (σ):  {sigma:.2e} S/m")
print(f"Derived Rel. Permittivity (εr = 1+χe): {epsilon_r:.2f}")
print(f"Derived Abs. Permittivity (ε):       {epsilon_abs:.3e} F/m")

print("\n--- Applied Field ---")
print(f"E-field = {E_field_vector} V/m")

print("\n--- Material Response ---")
print(f"Polarization P = ε₀ χe E      = {P_vector} C/m²")
print(f"Displacement D = ε E          = {D_vector_from_eps} C/m²")
print(f"Displacement D = ε₀E + P    = {D_vector_from_P} C/m²")
print(f" --> D fields match: {np.allclose(D_vector_from_eps, D_vector_from_P)}")
print(f"Current Density J = σ E     = {J_vector} A/m²")

# Note: If E_field was a complex phasor, these linear calculations
# would yield the corresponding complex phasors for P, D, and J.
            </code></pre>
        </div>
    </article>
    <article class="sub-section">
        <h3>Magnetic Relations (Briefly)</h3>
        <p>Similarly, magnetization \(\mathbf{M}\) is linked to \(\mathbf{H}\) by magnetic susceptibility \(\chi_m\): \( \mathbf{M} = \chi_m \mathbf{H} \). Leading to \( \mathbf{B} = \mu \mathbf{H} \) where \( \mu_r = 1 + \chi_m \).</p>
    </article>
    <p class="highlight">These linear relations also hold for their corresponding complex phasors.</p>
</section> <!-- End Constitutive -->


<!-- ================================== -->
<!-- == SECTION: Complex Permittivity == -->
<!-- ================================== -->
<section id="complex-permittivity" class="content-card animated" data-section-id="complex-permittivity" data-animation-container-id="p5-canvas-complex-epsilon">
    <h2>Complex Permittivity \( \varepsilon_c \): Packing Loss into \( \varepsilon \)</h2>
    <p>Combining phasor Ampère-Maxwell with constitutive relations \( \mathbf{\mathcal{J}} = \sigma \mathbf{\mathcal{E}} \) and \( \mathbf{\mathcal{D}} = \varepsilon \mathbf{\mathcal{E}} \):</p>
    \[ \nabla \times \mathbf{\mathcal{H}} = (\sigma - i\omega \varepsilon) \mathbf{\mathcal{E}} \]
    <p>Define <strong>complex permittivity \( \varepsilon_c \)</strong> so \( \nabla \times \mathbf{\mathcal{H}} \equiv -i\omega \varepsilon_c \mathbf{\mathcal{E}} \). Comparing yields:</p>
    <div class="highlight-box">
        <h4>Definition: Complex Permittivity (\(e^{-i\omega t}\) convention)</h4>
        <div class="equation">$$ \varepsilon_c = \varepsilon' + i \varepsilon'' = \varepsilon + i \frac{\sigma}{\omega} $$</div>
        <ul>
            <li>\(\varepsilon' = \varepsilon \): Real part (storage/polarization).</li>
            <li>\(\varepsilon'' = \sigma/\omega\): Positive imaginary part (loss/conduction).</li>
        </ul>
        <p>Relative: \( \varepsilon_{c,r} = \varepsilon_c / \varepsilon_0 = \varepsilon_r + i \frac{\sigma}{\omega \varepsilon_0} = \varepsilon'_r + i \varepsilon''_r \).</p>
    </div>
    <p>This simplifies wave analysis via the Helmholtz equation \( \nabla^2 \mathbf{\mathcal{E}} + k^2 \mathbf{\mathcal{E}} = 0 \) with complex wave number \( k^2 = \omega^2 \mu \varepsilon_c \).</p>
     <h4 class="python-example-title">Python Example #5: Complex Permittivity & Wave Number</h4>
     <p class="text-muted">Calculating \( \varepsilon_c \) and complex \(k\).</p>
     <div class="code-container">
         <button class="copy-btn" title="Copy code"><svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
        <pre><code class="language-python">
# === Example 5: Complex Permittivity & Wave Propagation ===
import numpy as np
from scipy.constants import epsilon_0, mu_0, pi, c # Speed of light in vacuum

def calculate_wave_properties(eps_r, sigma, freq_hz, mu_r=1.0):
    """
    Calculates complex permittivity, wave number, and related
    propagation constants for a material at a given frequency.
    Uses e^-iwt convention.

    Args:
        eps_r (float): Relative permittivity (real part).
        sigma (float): Conductivity (S/m).
        freq_hz (float): Frequency (Hz).
        mu_r (float): Relative permeability (default 1.0 for non-magnetic).

    Returns:
        dict: Dictionary containing calculated properties, or None if freq invalid.
    """
    if freq_hz <= 0:
        print("ERROR: Frequency must be positive.")
        return None

    omega = 2 * pi * freq_hz
    mu_abs = mu_r * mu_0      # Absolute permeability

    # 1. Calculate Relative Complex Permittivity (eps_c_rel = e'r + i*e''r)
    eps_prime_rel = eps_r
    eps_double_prime_rel = sigma / (omega * epsilon_0)
    eps_c_rel = complex(eps_prime_rel, eps_double_prime_rel)

    # 2. Calculate Absolute Complex Permittivity (eps_c = eps_0 * eps_c_rel)
    epsilon_c_abs = epsilon_0 * eps_c_rel

    # 3. Calculate Complex Wave Number (k = w * sqrt(mu * eps_c))
    # Handle the square root branch correctly for attenuation (alpha > 0)
    # k = beta + i*alpha for e^(ikz) propagation term where alpha represents loss.
    sqrt_term = np.sqrt(mu_abs * epsilon_c_abs + 0j) # Ensure input is complex
    k = omega * sqrt_term

    # Ensure the imaginary part (alpha) is positive for physical attenuation
    if k.imag < 0:
        k = -k

    beta = k.real   # Phase constant (rad/m)
    alpha = k.imag  # Attenuation constant (nepers/m)

    # 4. Calculate other useful properties
    wavelength_medium = 2 * pi / beta if beta > 1e-9 else float('inf')
    # Penetration depth (delta = 1/alpha)
    penetration_depth = 1 / alpha if alpha > 1e-9 else float('inf')
    # Attenuation in dB/m
    alpha_db_per_m = 20 * alpha / np.log(10) # approx 8.686 * alpha_np
    # Phase velocity (vp = omega / beta)
    phase_velocity = omega / beta if beta > 1e-9 else float('inf')
    # Refractive index (complex: n_c = sqrt(mu_r * eps_c_rel) = c0/vp + i*c0*alpha/omega)
    n_complex = c0 * k / omega # Complex refractive index n + ikappa
    refractive_index_real = n_complex.real
    extinction_coefficient = n_complex.imag

    return {
        "frequency_ghz": freq_hz / 1e9,
        "eps_r": eps_r,
        "sigma_sm": sigma,
        "eps_c_relative": eps_c_rel,
        "eps_prime_relative": eps_prime_rel,
        "eps_double_prime_relative": eps_double_prime_rel,
        "wavenumber_k": k,
        "phase_constant_beta_rad_m": beta,
        "attenuation_alpha_np_m": alpha,
        "attenuation_alpha_db_m": alpha_db_per_m,
        "wavelength_m": wavelength_medium,
        "penetration_depth_m": penetration_depth,
        "phase_velocity_m_s": phase_velocity,
        "complex_refractive_index": n_complex,
        "refractive_index_n": refractive_index_real,
        "extinction_coeff_kappa": extinction_coefficient
    }

# --- Run Examples ---
print("--- Example 1: Low-Loss Material (e.g., Glass @ 1 THz) ---")
props1 = calculate_wave_properties(eps_r=4.0, sigma=1e-4, freq_hz=1e12)
if props1:
    print(f"  Rel. εc ≈ {props1['eps_c_relative']:.3f}")
    print(f"  Wave# k ≈ {props1['wavenumber_k'].real:.1f} + {props1['wavenumber_k'].imag:.4f}j rad/m")
    print(f"  Attrib α ≈ {props1['attenuation_alpha_db_m']:.3f} dB/m (Low)")
    print(f"  Wavelen λ ≈ {props1['wavelength_m']*1e6:.1f} μm") # Micrometers
    print(f"  Pen. Depth δ ≈ {props1['penetration_depth_m']:.2f} m")
    print(f"  Phase Vel. vp ≈ {props1['phase_velocity_m_s']/c0:.3f} c")
    print(f"  Complex Index nc ≈ {props1['complex_refractive_index']:.3f}")

print("\n--- Example 2: Lossy Material (Muscle Tissue @ 2.45 GHz) ---")
# Approximate values for biological tissue
props2 = calculate_wave_properties(eps_r=47.0, sigma=1.8, freq_hz=2.45e9)
if props2:
    print(f"  Rel. εc ≈ {props2['eps_c_relative']:.3f}")
    print(f"  Wave# k ≈ {props2['wavenumber_k'].real:.1f} + {props2['wavenumber_k'].imag:.1f}j rad/m")
    print(f"  Attrib α ≈ {props2['attenuation_alpha_db_m']:.1f} dB/m (High)")
    print(f"  Wavelen λ ≈ {props2['wavelength_m']*100:.2f} cm") # Centimeters
    print(f"  Pen. Depth δ ≈ {props2['penetration_depth_m']*100:.2f} cm") # Penetration is cm!
    print(f"  Phase Vel. vp ≈ {props2['phase_velocity_m_s']/c0:.3f} c")
    print(f"  Complex Index nc ≈ {props2['complex_refractive_index']:.3f}")
        </code></pre>
    </div>
    <!-- Epsilon Explorer -->
    <article class="sub-section interactive-element animated" id="complex-epsilon-explorer">
         <h3 class="interactive-title">Explore Relative Complex Permittivity \( \varepsilon_c / \varepsilon_0 \)</h3>
         <p>Adjust the material's properties and frequency to see how \( \varepsilon'_r \) (storage) and \( \varepsilon''_r \) (loss) change, represented on the complex plane.</p>
         <div class="controls-grid">
             <div class="control-item"><label for="eps-r" id="eps-r-label">Rel. Permittivity (\(\varepsilon_r\)): <span id="eps-r-value" class="value-display">10.0</span></label> <input type="range" id="eps-r" min="1" max="100" value="10" step="0.5" aria-labelledby="eps-r-label"></div>
             <div class="control-item"><label for="sigma" id="sigma-label">Conductivity (\(\sigma\), S/m): <span id="sigma-value" class="value-display">0.10</span></label> <input type="range" id="sigma" min="0" max="10" value="0.1" step="0.05" aria-labelledby="sigma-label"></div>
             <div class="control-item"><label for="frequency" id="frequency-label">Frequency (f, GHz): <span id="frequency-value" class="value-display">1.0</span></label> <input type="range" id="frequency" min="0.1" max="100" value="1" step="0.1" aria-labelledby="frequency-label"></div>
        </div>
         <div class="results-container">
             <div id="complex-epsilon-output" class="output-box">
                <p><strong>Calculated Relative Values:</strong></p>
                 <!-- Corrected Frequency Span ID -->
                <p>\(f = \) <span id="frequency-ghz-display" class="result-value">-</span> GHz (\(\omega = \) <span id="omega-value" class="result-value">-</span> rad/s)</p>
                <p>\(\varepsilon'_r = \varepsilon_r = \) <span id="epsilon-prime-rel-value" class="result-value">-</span></p>
                <p>\(\varepsilon''_r = \sigma/(\omega \varepsilon_0) = \) <span id="epsilon-double-prime-rel-value" class="result-value">-</span></p>
                <p class="final-result">\( \varepsilon_{c,r} = \) <span id="epsilon-c-rel-value" class="result-value">-</span></p>
                <p class="interpretation"><span id="epsilon-interp">Adjust sliders...</span></p>
            </div>
             <div class="plot-box">
                <p><strong>Relative Complex Permittivity Plane</strong></p>
                <div id="complex-plane-plot-container">
                    <div id="complex-plane-plot"><div id="epsilon-point-marker" title="Value: X + Yj"></div></div>
                    <div class="axis-label axis-label-x">Real Part (\(\varepsilon'_r\))</div> <div class="axis-label axis-label-y">Imaginary Part (\(\varepsilon''_r\))</div>
                    <span class="plot-range plot-range-x-max">100</span> <span class="plot-range plot-range-y-max">20</span> <span class="plot-range plot-range-origin">0</span>
                 </div>
            </div>
        </div>
    </article>
</section> <!-- End Complex Permittivity -->


<!-- ============================== -->
<!-- == SECTION: Summary & Quiz === -->
<!-- ============================== -->
<section id="summary" class="content-card animated" data-section-id="summary">
    <h2>Summary & Test Your Understanding!</h2>
    <p>We've explored Maxwell's Equations, covering integral/differential forms, vector calculus theorems, phasor notation, material interactions (\(\chi_e, \varepsilon, \sigma\)), and complex permittivity \( \varepsilon_c = \varepsilon + i\sigma/\omega \).</p>
    <h3>Quick Quiz</h3>
    <p>Check your grasp of the main ideas.</p>
    <form id="quiz-form" novalidate>
         <div class="quiz-question animated" data-question="1"><p><strong>1.</strong> Deriving \( \nabla \cdot \mathbf{D} = \rho \) from \( \oint \mathbf{D} \cdot d\mathbf{A} = Q_{enc} \) uses:</p><div class="quiz-options"><label><input type="radio" name="q1" value="stokes"> A) Stokes' Theorem</label><label><input type="radio" name="q1" value="divergence"> B) Divergence Theorem</label><label><input type="radio" name="q1" value="ohm"> C) Ohm's Law</label></div><div class="feedback"></div></div>
         <div class="quiz-question animated" data-question="2"><p><strong>2.</strong> For the \( \text{Re}\{ \mathcal{F} e^{-i\omega t} \} \) convention, \( \partial / \partial t \) acts on \( \mathcal{F} \) as:</p><div class="quiz-options"><label><input type="radio" name="q2" value="iomega"> A) Multiply by \( i\omega \)</label><label><input type="radio" name="q2" value="-iomega"> B) Multiply by \( -i\omega \)</label><label><input type="radio" name="q2" value="omega2"> C) Multiply by \( \omega^2 \)</label></div><div class="feedback"></div></div>
         <div class="quiz-question animated" data-question="3"><p><strong>3.</strong> How is relative permittivity \( \varepsilon_r \) related to electric susceptibility \( \chi_e \)?</p><div class="quiz-options"><label><input type="radio" name="q3" value="inv"> A) \( \varepsilon_r = 1 / \chi_e \)</label><label><input type="radio" name="q3" value="sub"> B) \( \varepsilon_r = 1 - \chi_e \)</label><label><input type="radio" name="q3" value="add"> C) \( \varepsilon_r = 1 + \chi_e \)</label></div><div class="feedback"></div></div>
        <div class="quiz-question animated" data-question="4"><p><strong>4.</strong> Approx. relative imaginary permittivity \( \varepsilon'' / \varepsilon_0 \) for \( \varepsilon_r = 6 \), \( \sigma = 0.02 \) S/m, at \( f = 4 \) GHz? <br><small>(Use \( \varepsilon'' / \varepsilon_0 = \sigma / (\omega \varepsilon_0) \), \( \omega=2\pi f \), \( \varepsilon_0 \approx 8.854 \times 10^{-12} \) F/m).</small></p><div class="quiz-input-group"><input type="number" step="any" name="q4" placeholder="Enter value..." required><small class="text-muted">Hint: \(0.02 / (8\pi \times 10^9 \times 8.854 \times 10^{-12})\)</small></div><div class="feedback"></div></div>
        <button type="submit" class="btn btn-primary quiz-submit-btn">Check Answers</button>
    </form>
    <div id="quiz-overall-results" class="output-box quiz-results animated" style="margin-top: 1.5em; display: none;">
        <h4>Quiz Summary</h4>
        <p>You got <span id="quiz-score">0</span> out of <span id="quiz-total">4</span> correct!</p>
        <button id="quiz-retry-btn" class="btn btn-secondary" style="display: none;">Retry Quiz</button>
    </div>
</section> <!-- End Summary -->

<!-- ======================== -->
<!-- == SECTION: Glossary === -->
<!-- ======================== -->
<section id="glossary" class="content-card animated" data-section-id="glossary">
    <h2>Glossary of Key Terms</h2>
     <dl><dt>Phasor (\(\mathcal{E}, \mathcal{B}\))</dt><dd>Complex amplitude (\(A_0 e^{i\phi}\)) representing a time-harmonic quantity, simplifying analysis (\( \partial/\partial t \leftrightarrow -i\omega \)).</dd><dt>Electric Susceptibility (\(\chi_e\))</dt><dd>Dimensionless measure of a dielectric's polarizability (\( \mathbf{P} = \varepsilon_0 \chi_e \mathbf{E} \)).</dd><dt>Permittivity (\(\varepsilon = \varepsilon'\))</dt><dd>Real part of \(\varepsilon_c\) (F/m); energy storage via polarization (\( \varepsilon = \varepsilon_0 (1 + \chi_e) \)).</dd><dt>Relative Permittivity (\(\varepsilon_r\))</dt><dd>Dimensionless \( \varepsilon / \varepsilon_0 = 1 + \chi_e \).</dd><dt>Permeability (\(\mu\))</dt><dd>Material property (H/m) related to magnetization.</dd><dt>Conductivity (\(\sigma\))</dt><dd>Material property (S/m) describing conduction current (\(\mathbf{J}=\sigma\mathbf{E}\)); related to energy loss.</dd><dt>Complex Permittivity (\(\varepsilon_c\))</dt><dd>Complex quantity (\(\varepsilon_c = \varepsilon' + i\varepsilon''\)) combining storage (\(\varepsilon'\)) and loss (\(\varepsilon'' = \sigma/\omega\)).</dd><dt>Relative Complex Permittivity (\( \varepsilon_{c,r} \))</dt><dd>Dimensionless \( \varepsilon_c / \varepsilon_0 = \varepsilon'_r + i \varepsilon''_r \).</dd><dt>Loss Factor (\(\varepsilon''\))</dt><dd>Imaginary part of \(\varepsilon_c\), represents energy dissipation.</dd><dt>Loss Tangent (\( \tan \delta \))</dt><dd>Ratio \( \varepsilon'' / \varepsilon' \), indicating relative loss vs. storage.</dd><dt>Divergence (\(\nabla \cdot\)) & Curl (\(\nabla \times\))</dt><dd>Vector operators measuring field source density and circulation density.</dd><dt>Divergence Thm. & Stokes' Thm.</dt><dd>Link integral (flux, circulation) to differential (divergence, curl) forms.</dd></dl>
</section> <!-- End Glossary -->

{% endblock %}


{% block animations %}
    <!-- Define p5 canvas containers (IDs MUST match data-animation-container-id) -->
    <div id="p5-canvas-intro" class="animation-container sticky-animation"></div>
    <div id="p5-canvas-foundation" class="animation-container sticky-animation"></div>
    <div id="p5-canvas-bridging" class="animation-container sticky-animation"></div>
    <div id="p5-canvas-phasor" class="animation-container sticky-animation"></div>
    <div id="p5-canvas-materials" class="animation-container sticky-animation"></div>
    <div id="p5-canvas-complex-epsilon" class="animation-container sticky-animation"></div>
{% endblock %}
